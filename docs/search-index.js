var N=null,E="",T="t",U="u",searchIndex={};
var R=["Attribute","option","event","usize","result","try_from","try_into","borrow","borrow_mut","type_id","ReaderForMicroXml","TagState"];
searchIndex["reader_for_microxml"]={"doc":"reader for microXml","i":[[3,R[10],"reader_for_microxml","struct Reader for MicroXml - the Class Rust has Structs +…",N,N],[12,"input",E,"reference to the xml string (no allocation)",0,N],[12,"indices",E,"Iterator CharIndices over the input string",0,N],[12,"tag_state",E,"I need to know the TagState for programming as a state…",0,N],[12,"last_char",E,"the last read character from the iterator",0,N],[4,"Event",E,"The reader_for_microxml returns events. The caller will…",N,N],[13,"StartElement",E,"Start of xml element  ",1,N],[13,"EndElement",E,"End of xml element  ",1,N],[13,R[0],E,"Attribute  ",1,N],[13,"TextNode",E,"Child Text between `StartElement` and `EndElement`.  ",1,N],[13,"Error",E,"Error when reading  ",1,N],[13,"Eof",E,"End of microXml document  ",1,N],[4,R[11],E,"internal enum: Tags are strings inside delimiters `< and >…",N,N],[13,"OutsideOfTag",E,"outside of tag  ",2,N],[13,"InsideOfTag",E,"inside of tag  ",2,N],[13,"Eof",E,"end of file  ",2,N],[11,"new",E,"Constructor. String is immutably borrowed here. No…",0,[[["str"]],["readerformicroxml"]]],[11,"read_event",E,"Reads the next event: StartElement, Attribute, Text,…",0,[[["self"]],[R[2]]]],[11,"read_event_internal",E,"Reads the next event (internal). The internal function can…",0,[[["self"]],[[R[1],[R[2]]],[R[2]]]]],[11,"read_element_name",E,"Reads the element name Propagation of Option None if is…",0,[[["self"]],[[R[1],[R[2]]],[R[2]]]]],[11,"read_attribute",E,"Reads the attribute name and value. Return Option None if…",0,[[["self"]],[[R[1],[R[2]]],[R[2]]]]],[11,"read_end_element",E,"reads end element  ",0,[[["self"]],[[R[1],[R[2]]],[R[2]]]]],[11,"read_text_node",E,"Reads text node I don't do any encoding/decoding here,…",0,[[["self"],[R[3]]],[[R[1],[R[2]]],[R[2]]]]],[11,"skip_comment",E,"Comments are not data for MicroXml standard, They are…",0,[[["self"]],[[R[1],[R[3]]],[R[3]]]]],[11,"move_next_char",E,"Moves the iterator and stores the last_char. Iterator…",0,[[["self"]],[[R[1],[R[3]]],[R[3]]]]],[11,"get_last_char",E,"Returns the last_char, but doesn't move the iterator.…",0,[[["self"]]]],[11,"skip_whitespace_and_get_last_char",E,"Skips all whitespaces if there is any and returns the…",0,[[["self"]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[5],E,E,0,[[[U]],[R[4]]]],[11,R[6],E,E,0,[[],[R[4]]]],[11,R[7],E,E,0,[[["self"]],[T]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],["typeid"]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"to_owned",E,E,1,[[["self"]],[T]]],[11,"clone_into",E,E,1,[[["self"],[T]]]],[11,R[5],E,E,1,[[[U]],[R[4]]]],[11,R[6],E,E,1,[[],[R[4]]]],[11,R[7],E,E,1,[[["self"]],[T]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],["typeid"]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[5],E,E,2,[[[U]],[R[4]]]],[11,R[6],E,E,2,[[],[R[4]]]],[11,R[7],E,E,2,[[["self"]],[T]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],["typeid"]]],[11,"clone",E,E,1,[[["self"]],[R[2]]]],[11,"fmt",E,E,1,[[["self"],["formatter"]],[R[4]]]]],"p":[[3,R[10]],[4,"Event"],[4,R[11]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);